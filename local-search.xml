<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>时区细节问题</title>
    <link href="/2024/10/15/%E6%97%B6%E5%8C%BA%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/"/>
    <url>/2024/10/15/%E6%97%B6%E5%8C%BA%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="时区的常见划分"><a href="#时区的常见划分" class="headerlink" title="时区的常见划分"></a>时区的常见划分</h1><p>以格林尼治天文台旧址为零时区，东西各分12个时区，每个时区横跨经度15度；其中UTC+12和UTC-12是表示一个时区；UTC+12和UTC-12经度范围是从东经172.5度至西经172.5度，中线为180度经线，总共24个失去；</p><p>时区偏移量UTC offset，基本参照24时区来计算；<br>但是实际运用中通过时区偏移量划分时区时，还存在偏移半个时区或偏移四分之一时区的情况。</p><h1 id="特殊偏移的地区或城市："><a href="#特殊偏移的地区或城市：" class="headerlink" title="特殊偏移的地区或城市："></a>特殊偏移的地区或城市：</h1><p>UTC-9:30 French Polynesia Atuona 法属波利尼西亚 阿图奥纳</p><div><img src="https://img.xfiled.one/blog/Polynesia%20Atuona.svg" width="200"> <img src="https://img.xfiled.one/blog/Canada.svg" width="200"></div>UTC-2:30 St. John's 圣约翰 Newfoundland and Labrador 紐芬蘭與拉布拉多省 Canada 加拿大<p>UTC+3:30 Isfahan, Karaj, Mashhad 马什哈德, Qom, Shiraz, Tabriz, Tehran 德黑兰 伊朗</p><div><img src="https://img.xfiled.one/blog/Iran.svg" width="200"> <img src="https://img.xfiled.one/blog/Afghanistan.svg" width="200"></div>UTC+4:30 Kabul Kandahar Mazari Sharif, Afghanistan 阿富汗UTC+5:30 India Ahmedabad Bengaluru Chennai Hyderabad Kanpur Kolkata Mumbai New Delhi Pune Surat 印度Sri Lanka Colombo Moratuwa 斯里兰卡UTC+5:45 Nepal Biratnagar Kathmandu Pokhara 尼泊尔<div><img src="https://img.xfiled.one/blog/India%20Nepal%20Sri%20Lanka.svg" width="200"> <img src="https://img.xfiled.one/blog/Myanmar.svg" width="200"></div>UTC+6:30 Cocos (Keeling) Islands, Australian external territory Naypyidaw Yangon, Myanmar 缅甸<p>UTC+8:45 Australia 澳大利亚<br>UTC+9:30 Australia Darwin Northern Territory 澳大利亚<br>UTC+10:30 Australia Adelaide Adelaide Hills South Australia 澳大利亚</p><div><img src="https://img.xfiled.one/blog/Australia.svg" width="200"> <img src="https://img.xfiled.one/blog/Newzealand.svg" width="200"></div><h1 id="特殊扩展位移时区"><a href="#特殊扩展位移时区" class="headerlink" title="特殊扩展位移时区"></a>特殊扩展位移时区</h1><p>UTC+13 Auckland Wellington Samoa Apia Tokelau Tonga Nuku’alofa New Zealand 新西兰<br>UTC+14 Tabwakea Village, Kiribati 基里巴斯</p><div><img src="https://img.xfiled.one/blog/Kiribati.svg" width="200"></div><h1 id="特殊地点"><a href="#特殊地点" class="headerlink" title="特殊地点"></a>特殊地点</h1><p>Itascatown pre-WW2 二战前的伊塔斯卡镇（已被日本炸毁），位于豪兰岛，属于美国海外小岛屿；<br>Millersville - pre-WW2 settlement 二战前定居点</p><p>引用：The settlement Itascatown, near the beach on the island’s western side, was a line of no more than half a dozen small wood-frame structures and tents named after the U.S. Coast Guard vessel that brought them and made regular cruises between the islands during that era.</p><p>参考资料：<a href="https://dlab.epfl.ch/wikispeedia/wpcd/wp/h/Howland_Island.htm">https://dlab.epfl.ch/wikispeedia/wpcd/wp/h/Howland_Island.htm</a></p><h1 id="城市重名问题"><a href="#城市重名问题" class="headerlink" title="城市重名问题"></a>城市重名问题</h1><p>León<br>St. John’s</p><h1 id="夏令时DST的由来"><a href="#夏令时DST的由来" class="headerlink" title="夏令时DST的由来"></a>夏令时DST的由来</h1><p>又称夏时制，日光时间，日光节约时间，是一种在夏季月份牺牲正常的日出时间，而将时间调快的做法。夏季挑快1小时；</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Date对象</title>
    <link href="/2024/10/14/Date%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/10/14/Date%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>每个网页和新闻都离不开时间，但是当人们在网络上阅读消息时往往对时间概念是模糊的；</p><p>需要注意，不管你如何实例化一个 Date 对象，js在本地存储时，都会将它转换成本地时区。js 不会帮你存储实例化该日期时的时区信息。</p><p>It’s important to keep in mind that the date and time is stored in the local time zone, and that the basic methods to fetch the date and time or its components all work in the local time zone as well.</p><p>new Date(‘June 15, 2019 23:15:30 GMT+10:00’)；</p><p>&#x2F;&#x2F; 东10区的时间，实例化成功后，日期被转换成了本地时区<br>&#x2F;&#x2F; Sat Jun 15 2019 21:15:30 GMT+0800 (中国标准时间)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端开发回顾</title>
    <link href="/2024/10/12/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9B%9E%E9%A1%BE/"/>
    <url>/2024/10/12/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>Webpack 通过将模块代码放到一个函数内执行，利用函数作用域解决了模块之间变量污染的问题；<br>并且为了不影响全局，整个运行过程是在一个立即执行函数内完成。</p><p>Vite比Webpack启动快的原因是，不需要编译直接启动；Webpack是基于nodejs构建，Vite是基于esbuild进行预构建依赖，esbuild是采用Go语言编写。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis回顾</title>
    <link href="/2024/10/11/Redis%E5%9B%9E%E9%A1%BE/"/>
    <url>/2024/10/11/Redis%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>Redis (Remote Dictionary Service)</p><ol><li><p>Redis缓存雪崩<br>过期时间额外增加一些随机时间，尽量是几分钟<br>加互斥锁<br>在0点前提前加载Redis缓冲</p></li><li><p>Redis缓存击穿</p></li><li><p>Redis缓存穿透<br>一直查询id为-1的数据</p></li><li><p>业务可靠性处理</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java回顾</title>
    <link href="/2024/10/10/Java%E5%9B%9E%E9%A1%BE/"/>
    <url>/2024/10/10/Java%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>Keywords:48<br>abstract 抽象类,boolean,break,byte 有符号整数-128~127,case,<br>catch,char ‘A’,class,continue,default,do,double 双精度浮点类型的变量,<br>else,enum,extends 类或接口继承,final 定义后不能被修改,finally,float 单精度浮点数,for,if,implements 用于实现接口,import,instanceof,int,interface,long,<br>native 用于声明本地方法,new,null,package,private,protected,public,return,<br>short 用于表示短整数，占用 2 个字节（16 位）的内存空间,static,strictfp 少见,<br>super,switch,<br>synchronized ***用于指定多线程代码中的同步方法、变量或者代码块,<br>this,throw,throws,transient,try,void,<br>volatile 保证不同线程对它修饰的变量进行操作时的可见性,<br>while</p><p>Reserved word:2<br>goto, goto 在 C语言中叫做‘无限跳转’语句<br>const, const 在 C语言中是声明常量的关键字</p><p>基础数据类型:8种，延升概念：常量缓存池<br>boolean - Boolean（对应包装类）<br>char - Character<br>byte - Byte<br>short - Short<br>int - Integer<br>long - Long<br>float - Float<br>double - Double</p><p>引用数据类型:3种<br>数组，接口，类</p><p>Garbage Collection，缩写为GC</p><p>Synchronized vs ReentrantLock Optimal Locking Choice</p><p>线程安全（Thread Safety）和线程不安全（Thread Unsafe）</p><p>本地锁 和 分布式锁 Local Lock vs Distributed Lock<br>Synchronized, Re-entrant Lock and Redis,Zookeeper<br><a href="https://www.lenshood.dev/2020/02/04/redis-distributed-lock/">https://www.lenshood.dev/2020/02/04/redis-distributed-lock/</a></p><p>JDK1.7 JDK1.8<br>在JDK1.7中，由”数组+链表“组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p><p>Hashmap 的长度为2的幂次方 Power of 2</p><p>链表超过8且数组长度超过64才会转为红黑树；RTB<br><a href="https://crossoverjie.top/JCSprout/#/collections/HashMap">https://crossoverjie.top/JCSprout/#/collections/HashMap</a><br><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a><br><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/#Base-1-8">https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/#Base-1-8</a></p><p>ConcurrentHashMap 应运而生<br>HashSet 是基于 HashMap 实现的，底层采用 HashMap 来保存元素</p><p>volatile 可以保证可见性，但不保证原子性，禁止指令重排序；</p><p>Atomicity(ˌadəˈmisədē), Visibility, Ordering<br>原子性（Atomicity），可见性，有序性是并发的三大特征，所谓原子性，就是一个操作要么全部执行，要么都不执行。</p><p>Synchronized<br>基于CAS实现的原子类，CAS 的全称是Compare-And-Swap，底层是lock cmpxchg指令<br>Reentrant Lock, 锁机制<br>参考资料：<a href="https://blog.csdn.net/feinifi/article/details/94174492">https://blog.csdn.net/feinifi/article/details/94174492</a></p><p>Synchronized, ReentrantLock 一般划为悲观锁；CAS 为乐观锁，可以避免死锁；</p><p>什么是CAS，V要更新的变量var，E预期值expected，N新值new；<br>JDK 是在 1.5 版本后才引入 CAS 操作<br><a href="https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/java/juc/%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E7%9A%84CAS%E5%8E%9F%E7%90%86%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97.md">https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/java/juc/%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E7%9A%84CAS%E5%8E%9F%E7%90%86%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97.md</a></p><p>线程Thread和进程Process的区别：</p><p>Process<br>进程是应用程序的一次运行活动；从操作系统核心角度来说，进程是操作系统分配和调度系统内存资源、cpu时间片等资源的基本单位，为正在运行的应用程序提供运行环境。<br>进程就是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。</p><p>Thread<br>线程是程序内部有并发性的顺序代码流。是cpu调度资源的最小单元。</p><p>进程是系统资源分配和调度的基本单位，它能并发执行较高系统资源的利用率。<br>线程是比进程更小的能独立运行的基本单位。</p><p>ThreadLocal 是干嘛的？</p><p><a href="https://zhoukekestar.github.io/notes/2018/02/09/process-thread.html">https://zhoukekestar.github.io/notes/2018/02/09/process-thread.html</a></p><p>Java OOP:封装(Encapsulation),继承(Inheritance),多态(Polymorphism); 抽象(Abstraction)</p><p>Interface vs Abstract class</p><img src="https://img.xfiled.one/blog/java2.png" width="400px"><p>implements 可以扩展多个interface, extends 只能继承一个类；<br>interface 需要static或default方法；<br>interface中的基本数据类型为public static final，且需要给初始值；</p><p>Overriding vs Overloading<br>Overloading: 在同一个类中，有两个或多个具有相同方法名和不同的参数的方法，称作重载。<br>Overriding: 在不同类中（指父类和子类）中，两个具有相同方法名和相同参数的方法，称作重写。</p><p>LinkedList 和 ArrayList<br>ArrayList 基于数组，LinkedList 基于链表；</p><p>泛型 Generics<br>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法<br>&#x2F;&#x2F;此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型<br><a href="https://liaoxuefeng.com/books/java/generics/what-is-generics/index.html">https://liaoxuefeng.com/books/java/generics/what-is-generics/index.html</a></p><p>泛型擦除 Generic Erasure<br>在编译阶段使用泛型，运行阶段取消泛型，即擦除。<br>When compiling use generics,but when running time cancel it.</p><p>JMM Java Memory Model</p><p>锁升级的过程：无锁-&gt;偏向锁-&gt;自旋锁-&gt;重量级锁</p><p>多线程如何使用：<br>1、继承Thread类，重写run()方法<br>2、实现Runnable接口，重写run()<br>3、实现 Callable 接口<br>4、使用线程池创建</p><p>浅拷贝<br>Just copy a pointer to an object，并不是真的拷贝，只是复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。<br>深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><p>Kafka<br>Broker 集群 Broker Cluster</p><p>Kafka 性能高原因：<br>利用了 PageCache 缓存，内存中开辟一块区域写入磁盘缓冲，直接写内存；<br>磁盘顺序写，批量写磁盘，(log.flush.interval.messages​,log.flush.interval.ms)<br>批量压缩传输 Kafka Client to Kafka Server compression transmission(gzip)<br>pull 拉模式，sendfile系统调用<br>多 partition 分散存储</p><p>Kafka 的应用场景：<br>日志聚合：可收集各种服务的日志写入kafka的消息队列进行存储<br>消息系统：广泛用于消息中间件<br>系统解耦System decoupling：在重要操作完成后，发送消息，由别的服务系统来完成其他操作<br>流量削峰：一般用于秒杀或抢购活动中，来缓冲网站短时间内高流量带来的压力<br>异步处理Asynchronous Processing：通过异步处理机制，可以把一个消息放入队列中，但不立即处理它，在需要的时候再进行处理</p><p>MMAP<br>简称mmap，简单描述其作用就是：将磁盘文件映射到内存, 用户通过修改内存就能修改磁盘文件。</p><p><a href="https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/mq/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%EF%BC%8Ckafka%E5%88%B0%E5%BA%95%E4%BC%9A%E4%B8%8D%E4%BC%9A%E4%B8%A2%E6%B6%88%E6%81%AF.md">https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/mq/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%EF%BC%8Ckafka%E5%88%B0%E5%BA%95%E4%BC%9A%E4%B8%8D%E4%BC%9A%E4%B8%A2%E6%B6%88%E6%81%AF.md</a></p><p>Spring 和 SpringBoot 区别<br>Spring的设计模式<br>Java 22,17,23，稳定版本22.0.2<br>Error和Exception的区别<br>Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。<br>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p><p>JVM<br>1、程序计数器<br>2、Java 虚拟机栈<br>3、本地方法栈<br>4、堆<br>5、方法区<br><a href="https://doocs.github.io/jvm/01-jvm-memory-structure.html">https://doocs.github.io/jvm/01-jvm-memory-structure.html</a></p><p>JDK<br><a href="https://en.wikipedia.org/wiki/Java_version_history">https://en.wikipedia.org/wiki/Java_version_history</a></p><p>Maven<br>exclusion 去除某一个依赖下的特定子依赖<br><exclusion><br>  <groupId>org.slf4j</groupId><br>  <artifactId>slf4j-log4j12</artifactId><br></exclusion></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS库开发流程</title>
    <link href="/2024/10/10/JS%E5%BA%93%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/10/10/JS%E5%BA%93%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>想要真正实现一个库，需要完成从想法到目标，从目标到设计，从设计到编码的流程；</p><div style="text-align:left;">  <div style="display:block;height:201px;"><img src="https://img.xfiled.one/blog/process1.drawio.svg" align="left" height="201"/></div>  <div style="display:block;font-size:14px;">JS库开发流程</div></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
